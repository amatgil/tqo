* TQO
A LTR, strongly typed apl

*NOTE: THIS IS INCREDIBLY, INCREDIBLY EARLY STAGE: THE IMPLEMENTATION DOES NOT YET EXIST*

(this file is best viewed with an APL font, such as [[https://dyalog.github.io/APL387/][APL387]])

** Key features
*** Array model
Based.

On top of arrays, we have haskell-esque =data= ADTs: one may define enummerations (see [[*Type declarations][the corresponding section]])

*** Left To Right
This mainly manifests in the convention for functions becoming: input on the left, data on the right.

*** TODO Fixed arity
# Some glyphs (like =⍟= log) may be ambivalent (default argument ones are good candidates). However, examples tally being the same as notmatch sucks for Notation as a Tool of Thought :/

*** Naming things: considered good
In a definition, each name may only refer to one thing (this avoids confusion with regard to "what does omega refer to in this scope?")

To achieve this, instead of just alpha and omega (and their underscores for modifiers), more glyphs of the greek alphabet: each level of dfn nesting will add two more greek letters (from either side of the alphabet), such that alpha and omega always refer to the outermost arguments, beta and psi refer to the next level of nesting's arguments, etc.

*** Strongly typed

Every function must* have a static type, which consists of either rank or the dimensions of the axes, as well as the underlying scalar type.

*in the future

*** Monadic functions' arguments doesn't have to always be on the left
A monadic function may take a singular omega (and thus have type =: Example « 2,N=). That is, a function may be defined to only take a right argument (for example, negation).

** Repl, tooling (mostly focused for use in emacs)
(Still unimplemented)

The repl is to take take input, both from normal typing and from "behind". The idea is that you can =)ed Foo= and it'll open up another buffer that has =Foo<-{}=. Any time you save that buffer, the _repl's definition of Foo_ also changes for phenomenal debugging.  A way to save like that would be a =)save_background Foo {}= that doesn't get shown in the buffer. Unanswered question: would there be an ergonomic way to push it to a file?

*** Extra
Chord to open emacs buffer with list of greek letters (like =unicode-chars-list-chars=), all primitives with their unicode name and their tqo name; and subscripts.

** Others
I expect to make a full, usable shell with it and replace zsh with it (à la nushell) [fn:2]
 


#+begin_src 
  ls                                 ⍝ Would output a list of files
  cd "foo" 
  read "file.txt" (⊣⊆≠)'\n' ⋕⍤¯1 /+  ⍝ Add up all the numbers in file.txt
#+end_src

** Brainstorm
*** Namespaces
literally dyalog, quad NS

** Type annotations
They must always exist. If they cannot be inferred, it errors out.

Type annotations must take the form of (written in Rust-ish pseudocode)
#+begin_src rust
  struct TypeAnnotation {
      scalar_type: ScalarType,                    // The type
      shape: ShapeDescription,                    // And the shape
  }

  enum ShapeDescription {      
      Rank(usize),                                // We know the number of axis
      Axes(Vec<(Option<String>, Option<usize>)>), // We may know the size or name of each axis. Implies rank
  }
#+end_src

Annotations must go directly above the function definition:
(the separator (currently the =,=) between the rank/shape and the scalar type is very TBD)
THIS IS PRETTY OUTDATED
#+begin_example tqo
: '(4) » foo                                    ⍝ foo takes a rank 4 array of unspecified type
foo ← {α ⍝ Code goes here ⍝}

: '(4,'N) » foo                                 ⍝ foo takes a rank 4 array of naturals 
foo ← {α ⍝ Code goes here ⍝}

: '[3 _ , 'N] » bar                             ⍝ bar takes a rank 2 array whose leading dimension has size 3, of naturals
bar ← {α ⍝ Code goes here ⍝}

: '[width←512 height←512 color←_ , 'F] » baz    ⍝ baz takes a rank 3 array that represents a 512x512 
baz ← {α ⍝ Code goes here ⍝}                    ⍝ image (the dimension of the color axis is left unspecified) composed of
                                                ⍝ floats

: '(4,'N) » quz « (2,'N)                        ⍝ quz is a dyadic function that takes a rank-4 and a rank-2 array, both of naturals
quz ← {α ⍝ Code goes here ⍝}


: '(1,'N) » waldo « (2,'N)                      ⍝ waldo is a dyadic function that takes rank-1 and rank-2 arrays of nats and outputs a rank-3 array of nats
           ↳ (3,N)
waldo ← {α ⍝ Code goes here ⍝}
                                            
#+end_example

**** TODO Update the other docs
#+begin_src tqo
: '(⍤, 'N) » Avg               ⍝ Rank goes down by one: declare rank, it'll decrease by one
             ↳ '(⍤-1, 'N)
Avg ← +/÷≢
 
: ∀T '(≢, T) » Avg             ⍝ Length is exactly 5: declare length, set it to five
               ↳ '(≢=5, 'T)
Take5 ← ↑5

: ∀T '(⍴, 'T) » Tra            ⍝ Length is exactly 5: declare length, set it to five
                ↳ '(⍴⇌, 'T)
Tra ← ⍉
#+end_src

*** Unsolved issues
How to annotate destructure/pattern match? e.g- =(l r) ← ...=

** Type declarations
=TQO= has full support for haskell-esque data definitions:

#+begin_src tqo
  ⍝ Note that this specific example is a tad unidiomatic, as these would be better
  ⍝ represented as raw naturals. However, it gets across the syntax well

  □ Suit    ← ⟨ Club ⋄ Diamond ⋄ Heart ⋄ Spade⟩      ⍝ Standard enumeration
  □ Value   ← ⟨ Two ⋄ Three ⋄ Four ⋄ Five
                    ⋄ Six ⋄ Seven ⋄ Eight
                    ⋄ Nine ⋄ Ten ⋄ Jack
                    ⋄ Queen ⋄ Kind ⋄ Ace ⟩    
  □ Card    ← ⟨ value: 'Value ⋄ suit: 'Suit ⟩        ⍝ Product type
  □ Player  ← ⟨ Host  ← ⟨ name: '(1, char) ⟩         ⍝ Sum type
                Guest ← ⟨ debt: 'Nat ⋄ hp: 'Float ⟩ ⟩        

#+end_src

These are intended to be used for grouping together state and documenting intention. Do note that the underlying datatypes (i.e. the ones that are properly computed over) should be arrays. For example, prefer using trees through parent/depth representations instead of defining it as an inductive type

Note also that product types are sugar for a sum type with a single unnamed variant. They may be spelt out explicitly:

#+begin_src tqo
  ⟨ value: 'Value ⋄ suit: 'Suit ⟩ ≡ ⟨ _ ← ⟨ value: 'Value ⋄ suit: 'Suit ⟩ ⟩
#+end_src

A more realistic example of product type usage:
#+begin_src 
  □ Graph  ← ⟨ data  ← '(1, T) ⋄ form ← '(1, Nat)  ⟩  ⍝ Generics' syntax is TBD
#+end_src

** Trains
Featuring the standard suite of trains:
- =(M D M)=
- =(D D D)=


** Other notes
No implicit stranding, it is done through ascii underscores

In all situations, a diamond is equivalent to a newline

All non-commutative functions must have non-symmetrical glyphs. 

Single quotes for single chars, double quotes for strings (i.e. lists of chars)

Inversionian lang go brr

*** Built-in Data Types
| Name            | Description                                       | Notes                                                                                                                      |
|-----------------+---------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------|
| 'Nat            | Arbitrary precision natural                       | Bools fall under this category, there is no distinct Boolean type                                                          |
| 'Int            | Arbitrary precision integer                       |                                                                                                                            |
| 'Float          | Double precision IEEEE floating point             |                                                                                                                            |
| 'Char           | Unicode codepoint                                 |                                                                                                                            |
| 'U{₈,₁₆,₃₂,₆₄}  | Unsigned value of {8,16,32,64} bits               |                                                                                                                            |
| 'I{₈,₁₆,₃₂,₆₄}  | Signed value of {8,16,32,64} bits                 |                                                                                                                            |
| 'U{₈,₁₆,₃₂,₆₄}I | Unsigned value of {8,16,32,64} bits with infinity | The value 0b111.111 is reinterpreted to be infinity; all arithmetic operations are saturating instead of over/underflowing |
| 'I{₈,₁₆,₃₂,₆₄}I | Signed value of {8,16,32,64} bits with ±infinity  | See  u{8,16,32,64}I                                                                                                        |

** Bunda-Gerth table
# https://dfns.dyalog.com/n_parse.htm

Legend:
| Name                   | Abreviation |
|------------------------+-------------|
| Array (Nilad)          | A           |
| Alpha-Monadic Function | αMF         |
| Omega-Monadic Function | ⍵MF         |
| Dyadic Function        | DF          |
| Name                   | N           |
| Alpha-Monadic Modifier | αMM         |
| Omega-Monadic Modifier | ⍵MM         |
| Dyadic Modifier        | DM          |
| Jot                    | JOT         |
| Assignment Arrow       | ARR         |
| Assignment             | ASS         |

# TODO: When the glyph for left/right placeholders for modifiers (i.e. dyalog's alphalpha and omegaomega)
# are decided, substitute them in in the legend and table

Table:
| Left\Right | A        | αMF      | ⍵MF      | DF       | N        | αMM      | ⍵MM      | DM      | JOT      | ARR       |
| /          | <        | <        | <        | <        | <        | <        | <        | <       | <        | <         |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| A          | _        | (x, A)   | _        | (x,⍵MF)  | _        | (x, A)   |          |         |          | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| αMF        | _        | (x, αMF) | _        | (x, DF)  | _        | (x, αMF) |          |         | err?     | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| ⍵MF        | (x, A)   | _        | (x,⍵MF)  |          | (x, A)   | (x, αMF) |          |         |          | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| DF         | (x,MFα)  | _        | (x, DF)  | _        | (x, αMF) | (x, αMF) |          |         |          | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| N          | _        | (x, A)   | _        | (x, ⍵MF) | _        | (x, αMF) |          |         |          | (x, bind) |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| αMM        | _        |          |          |          |          | (x, αMM) |          |         | err?     | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| ⍵MM        |          |          |          |          |          |          |          |         |          | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| DM         | (x, MM)  |          |          |          |          |          |          |         |          | (x, err)  |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| JOT        |          |          | err?     |          |          |          | err?     |         |          |           |
|------------+----------+----------+----------+----------+----------+----------+----------+---------+----------+-----------|
| ARR        | (x, ASS) | (x, ASS) | (x, ASS) | (x, ASS) | (x, ASS) | (x, ASS) | (x, ASS) | (x,ASS) | (x, err) | (x, err)  |


# │A a b c  0 1 2 3 4 5 6 7 8 9  ⍺ ⍵  #    ⍝ Arrays                              │
# │F + - × ÷ ⍳ ⍴ = | ↑ ↓ ⊢ ⊣ ∇             ⍝ Functions                           │
# │N x y z                                 ⍝ Names (unassigned).                 │
# │AF                                      ⍝ bound left argument                 │
# │JOT ∘                                   ⍝ compose / null operand.             │
# │DOT .                                   ⍝ ref / product.                      │
# │DX                                      ⍝ dotted ...                          │
# │MOP ¨ ⍨ &                               ⍝ Monadic operators                   │
# │DOP ⍣                                   ⍝ Dyadic operators                    │
# │IDX                                     ⍝ index/axis                          │
# │XAS                                     ⍝ indexed assignment: [IDX]←          │
# │SL  ;                                   ⍝ subscript list  ..;..;..            │
# │CLN :                                   ⍝ colon token                         │
# │GRD                                     ⍝ guard :                             │
# │XL  ⋄                                   ⍝ expression list ..⋄..⋄..            │
# │ARO ←                                   ⍝ assignment arrow                    │
# │ASG                                     ⍝ name assignment                     │
# │ERR                                     ⍝ error                               │
# │() [IDX] {F}                            ⍝ brackets                            │
# │⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝             
** List of primitives
Note that all non-commutative dyadic operations have non-symemtrical glyphs! (With the exceptions of: subtract, divide)

| Glyph  | Category   | Name             | Type     | Arity   | Notes                                      |
|--------+------------+------------------+----------+---------+--------------------------------------------|
| ¯      | Arithemtic | Negate           | Function | Monadic |                                            |
| ¬      | Arithmetic | Not              | Function | Monadic |                                            |
| ±      | Arithmetic | Sign             | Function | Monadic |                                            |
| +      | Arithemtic | Add              | Function | Dyadic  |                                            |
| -      | Arithmetic | Subtract         | Function | Dyadic  |                                            |
| ×      | Arithmetic | Multiply         | Function | Dyadic  |                                            |
| ÷      | Arithmetic | Divide           | Function | Dyadic  |                                            |
| ◿      | Arithmetic | Modulo           | Function | Dyadic  |                                            |
| TBD    | Arithmetic | Remainder        | Function | Dyadic  |                                            |
| ⌵      | Arithmetic | Absolute Value   | Function | Monadic |                                            |
| TBD    | Arithmetic | Sine             | Function | Monadic |                                            |
| ⨪      | Arithmetic | Reciprocal       | Function | Monadic |                                            |
| √      | Arithmetic | Sqrt             | Function | Monadic |                                            |
| ↥      | Arithmetic | Maximum          | Function | Dyadic  |                                            |
| ↧      | Arithmetic | Minimum          | Function | Dyadic  |                                            |
| ⌊      | Arithmetic | Floor            | Function | Monadic |                                            |
| ⁅      | Arithmetic | Round            | Function | Monadic |                                            |
| ⌈      | Arithmetic | Ceiling          | Function | Monadic |                                            |
| \equal | Logic      | Equals           | Function | Monadic |                                            |
| ≠      | Logic      | Not equals       | Function | Dyadic  |                                            |
| <      | Logic      | Less than        | Function | Dyadic  |                                            |
| ≤      | Logic      | Less or equal    | Function | Dyadic  |                                            |
| >      | Logic      | Greater than     | Function | Dyadic  |                                            |
| ≥      | Logic      | Greater or equal | Function | Dyadic  |                                            |
| ∧      | Logic      | And              |          |         |                                            |
| ∨      | Logic      | Or               |          |         |                                            |
| ⊼      | Logic      | Nand             |          |         |                                            |
| ⊽      | Logic      | Nor              |          |         |                                            |
| ⊻      | Logic      | Xor              |          |         | Extends to naturals as absolute difference |
| \vert  | Logic      | Divides          | Function | Dyadic  |                                            |
| ∤      | Logic      | Nodivides        |          |         |                                            |
| ⊣      |            | Left             | Function | Dyadic  |                                            |
| ⊢      |            | Right            | Function | Dyadic  |                                            |
| ⍋      |            | Grade up         | Function | Monadic |                                            |
| ⍒      |            | Grade down       | Function | Monadic |                                            |
| ⍉      |            | Transpose        | Function | Monadic |                                            |
| ⇡      |            | Range            | Function | Monad   |                                            |
| ⍆      |            | Sort             | Function | Monadic |                                            |
| √      |            | Sqrt             | Function | Monadic |                                            |
| ⇌      |            | Reverse          | Function | Monadic |                                            |
| ⋯      |            | Bits             | Function | Monadic | Equivalent to =encode2 =                   |
| ⍸      |            | Where            | Function | Monadic |                                            |
| ∊      | Logic      | Memberof         | Function | Dyadic  |                                            |
| ∋      | Logic      | Memberin         | Function | Dyadic  |                                            |
| ∉      | Logic      | Notmemberof      | Function | Dyadic  |                                            |
| ∌      | Logic      | Notmemberin      | Function | Dyadic  |                                            |
| ⌿      |            | Keep/Replicate   | Function | Dyadic  |                                            |
| ≢      |            | Tally/Length     | Function | Monadic |                                            |
|        |            | Depth            | Function | Monadic |                                            |
| ≍      |            | Match            | Function | Dyadic  |                                            |
| ≭      |            | Notmatch         | Function | Dyadic  |                                            |
| ⍴      |            | Shape            | Function | Monadic |                                            |
| ↯      |            | Reshape          | Function | Dyadic  |                                            |
| ⊞      |            | Table            | Modifier | Monadic |                                            |
| ⍜      |            | Under            | Modifier | Dyadic  |                                            |
| ⍣      |            | Repeat/Power     | Modifier | Dyadic  |                                            |


** Special syntax glyphs
| Glyph | Name            | Meaning                          |
|-------+-----------------+----------------------------------|
| :     | Type definition | Declare the type of an atom      |
| ⊔     | Destructure     | Start pattern matching           |
| ⊔     | Destructure     | Start pattern matching           |
| ⋄     | Diamond         | Statment separator               |
| ⎕     | Quad            | System function; Print to screen |

# | ⧻     |            | Length           | Function | Monadic |                                |
# | ≡     | Match            | Function | Dyadic  |                                |

# Note to self: the unicode list near #x002207 ∇ NABLA is a goldmine for glyphs!

* TODO Tacit
Being of fixed-arity, forks and atops look as follows:

....

	

f g Y
* TODO (design)
- Decide syntax for doccoments
- Document the fact it's leading axis (and that evert exists)
- Document that trains use moons
  - Think through another possible syntax for trains
- Document the fact that uppercase/lowercase have implications for functions/nouns
- Think hard about how to do generics/typeclasses
- Document the fact that all values are immutable. For mutability, use repeat and such
- Memory mapped files






[fn:1] I need to understand bqn's better to be able to decide properly, but so far the nested one (I'm conceptualizing it as fix=box) seem nice
[fn:2] for example, automatically running =tqo "--load shell_prelude.tqo"= on terminal startup (it would be a bad idea to not have bash or zsh as the true underlying shell, as many programs expect them to run all programs)
